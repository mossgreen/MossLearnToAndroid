package com.example.marslander;

import android.util.FloatMath;
import android.widget.FrameLayout;

public class Craft {
	protected class CraftModel{
		private static final float SIDE_THRUSTER_DURATION = 1.0f;
		private static final float MAIN_THRUSTER_DURATION = 1.0f;
		private static final float THRUSTER_DURATION = 7.0f;
		private static final FrameLayout FUEL_CONSUME = 2.0f;
		
		//state
		private float _headAngle = 0.0f; //indegee
		private boolean _isMainThrusterOn = false;
		private float _mainThrustTimespan;
		private boolean _isleftThrusterOn = false;
		private float _leftThrustTimespan;
		private boolean _isRightThrusterOn = false;
		private float _rightThrustTimespan;
		private float _fuelRemaining = 100.00f;
		
		//position
		private float _offsetX = 0;
		private float _offsetY = 0;
		
		//velocity in meters/second
		private float _veloX = 0;
		private float _veloY = 0;
		private float _g= 0;

		//acceleration in meters/ second^2
		private float _accelX = 0;
		private float _accelY = 0;
		
		public CraftModel(float g) {
			// TODO Auto-generated constructor stub
			_g = g;
			_accelY = _g;
		}
		
		//turn right when the craft remains enough fuel.
		protected void turnRight(){
			if(_isleftThrusterOn || _fuelRemianing <= 0){
				return;
			}
			_fuelRemaining = _fuelRemianing-FUEL_CONSUME;
			_headAngle += 18.0;
			_leftThrustTimespan = 0.0f;
			_isleftThrusterOn = true;
		}
		
		//turn left when the craft remians enought fuel
		protected void turnLeft(){
			if(_isRightThrusterOn || _fuleRemianing <= 0){
				return;
			}
			_fuelRemaining = _fuelRemaining - FUEL_CONSUME;
			_headAngle -= 18.0;
			_rightThrustTimespan = 0.0f;
			_isRightThrusterOn = true;
		}
		
		//thrust when the craft remians enought fuel
		protected void thrust(){
			if(_isMainThrusterOn || _fuleRemaining <= 0){
				return;
			}
			_mainThrustTimespan = 0.0f;
			_fuelRemaining = _fuleRemaining -FUEL_CONSUME;
			_isMainThrusterOn = true;
		}
		
		protected float getFuelRemaining(){
			return _fuelRemaining;
		}
		
		protected float getOffSetX(){
			return _offsetX;
		}
		
		protected float getOffSetY(){
			return _offsetY;
		}
		
		protected float getAngle(){
			return _headAngle;
		}
		
		protected boolean IsLeftThrusterOn(){
			return _isleftThrusterOn;
		}
		
		protected boolean IsRightThrusterOn(){
			return _isRightThrusterOn;
		}
		
		protected boolean IsMainthrusterOn(){
			return _isMainThrusterOn;
		}
		
		//update the status and position of the craft
		protected void update(float dt){
			//s = vt + 1/2at^2
			_offsetX  = _veloX * dt + _accelX * dt * dt/2;
			_offsetY = _veloY *dt + _accelY *dt * dt/2;
			
			
			//v' = v=at
			_veloX += _accelX * dt;
			_veloY += _accelY * dt;
			
			if(_isleftThrusterOn){
				_accelX = 5 *(float)Math.sin(Math.toRadians(_headAngle));
				_accelY = 5* -(float)Math.cos(Math.toRadians(_headAngle)) + _g;
				
				_leftThrustTimespan += dt;
				if(_leftThrustTimespan >= SIDE_THRUSTER_DURATION){
					_isleftThrusterOn = false;
					_accelX = 0;
					_accelY = _g;
				}
			}
			
			if(_isRightThrusterOn){
				_accelX = 5 *(float)Math.sin(Math.toRadians(_headAngle));
				_accelY = 5 * -(float)Math.cos(Math.toRadians(_headAngle))+_g;
				_rightThrustTimespan += dt;
				if(_rightThrustTimespan >= SIDE_THRUSTER_DURATION){
					_isRightThrusterOn = false;
					_accelX = 0;
					_accelY = _g;
				}
			}
			
			if(_isMainThrusterOn){
				_accelX = THRUSTER_ACCEL * (float)Math.sin(Math.toRadians(_headAngle));
				_accelX = THRUSTER_ACCEL * -(float)Math.cos(Math.toRadians(_headAngle))+ _g;
				_mainThrustTimespan += dt;
				if(_mainThrustTimespan >= MAIN_THRUSTER_DURATION){
					_isMainThrusterOn = false;
					_accelX = 0;
					_accelY = _g;
				}
			}
			
		}
	
	}
	
	
	
	
	
	
	

}
