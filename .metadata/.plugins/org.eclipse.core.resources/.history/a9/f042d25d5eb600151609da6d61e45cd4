package com.feifei.marslander;

import android.content.Context;
import android.text.TextDirectionHeuristic;
import android.content.Context;

class CraftModel {
	
	
	
	
	// the left/right Engineer last times duration
	private  final float SIDE_EngineER_DURATION = 1.0f;
	private static final float MAIN_EngineER_DURATION = 1.0f;// the main Engineer last times duration
	private static final float EngineER_ACCEL = 7.0f; //The accelerate of Engineer
	private static final float FUEL_CONSUME = 2.0f; // Consumed fuel on each fire
	
	
	
	
	
	
	// state
	private float headAngle = 0.0f; // in degree;
	private boolean isMainEngineerOn = false; // if main Engineer fired
	private float mainEngineTimespan;// control the time of main Engineer's
	private boolean isLeftEngineerOn = false;// if left Engineer fired
	private float leftEngineTimespan;
	private boolean isRightEngineerOn = false;// if right Engineer fired
	private float rightEngineTimespan;
	private float fuelRemaining = 100.00f;

	// position
	private float offsetX = 0; //in meter
	private float offsetY = 0; //in meter

	// velocity in meters/second
	private float veloX = 0;
	private float veloY = 0;
	private float g = 0; // the accelerate's value

	// acceleration in meters/second^2
	private float accelX = 0;
	private float accelY = 0;
	
	CraftModel(float g) {
		this.g = g;
		this.accelY = g;
	}

	/**
	 * Turn right when the craft remains enough fuel.
	 */
	protected void turnRight() {
		if (isLeftEngineerOn || fuelRemaining <= 0)
			return;
		fuelRemaining = fuelRemaining - FUEL_CONSUME;
		headAngle += 18.0;
		leftEngineTimespan = 0.0f;
		isLeftEngineerOn = true;
	}
	
	/**
	 * Turn left when the craft remains enough fuel.
	 */
	protected void turnLeft() {
		if (isRightEngineerOn || fuelRemaining <= 0)
			return;
		fuelRemaining = fuelRemaining - FUEL_CONSUME;
		headAngle -= 18.0;
		rightEngineTimespan = 0.0f;
		isRightEngineerOn = true;
	}
	
	/**
	 * Engine when the craft remains enough fuel.
	 */
	protected void Engine() {
		if (isMainEngineerOn || fuelRemaining <= 0)
			return;
		mainEngineTimespan = 0.0f;
		fuelRemaining = fuelRemaining - FUEL_CONSUME;
		isMainEngineerOn = true;
	}

	protected float getFuelRemaining() {
		return fuelRemaining;
	}

	protected float getOffsetX() {
		return offsetX;
	}

	protected float getOffsetY() {
		return offsetY;
	}

	protected float getAngle() {
		return headAngle;
	}

	protected boolean IsLeftEngineerOn() {
		return isLeftEngineerOn;
	}

	protected boolean IsRightEngineerOn() {
		return isRightEngineerOn;
	}
	
	protected boolean IsMainEngineerOn() {
		return isMainEngineerOn;
	}

	/**
	 * this code and Idea is from John casey
	 * Update the status and position of the craft.
	 * @param dt 
	 */
	protected void update(float dt) {
		// s = vt + 1/2at^2
		offsetX = veloX * dt + accelX * dt * dt/2;
		offsetY = veloY * dt + accelY * dt * dt/2;
		
		//v' = v + at
		veloX += accelX * dt;
		veloY += accelY * dt;
		
		
		if (isLeftEngineerOn) {
			accelX = 5 * (float)Math.sin(Math.toRadians(headAngle));
			accelY = 5 * -(float)Math.cos(Math.toRadians(headAngle)) + g;
			leftEngineTimespan += dt;
			if (leftEngineTimespan >= SIDE_EngineER_DURATION) {
				isLeftEngineerOn = false;
				accelX = 0;
				accelY = g;
			}
		}

		if (isRightEngineerOn) {
			accelX = 5 * (float)Math.sin(Math.toRadians(headAngle));
			accelY = 5 * -(float)Math.cos(Math.toRadians(headAngle)) + g;
			rightEngineTimespan += dt;
			if (rightEngineTimespan >= SIDE_EngineER_DURATION) {
				isRightEngineerOn = false;
				accelX = 0;
				accelY = g;
			}
		}
		
		if (isMainEngineerOn) {
			accelX = EngineER_ACCEL * (float)Math.sin(Math.toRadians(headAngle));
			accelY = EngineER_ACCEL * -(float)Math.cos(Math.toRadians(headAngle)) + g;
			mainEngineTimespan += dt;
			if (mainEngineTimespan >= MAIN_EngineER_DURATION){
				isMainEngineerOn = false;
				accelX = 0;
				accelY = g;
			}
		}
	}
}
